/**
 * @fileoverview Firestore Security Rules for Mesy Entertainment Universe.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private user data while allowing public read access to certain global collections.  Write access is always restricted to authorized users, based on ownership or role.  Data validation during writes is limited to authorization-critical fields.
 *
 * Data Structure:
 * - User-specific data (profiles, notifications, AI sessions, wallets, downlines) is stored under `/users/{userId}`.
 * - Global, publicly readable data (quests, rewards) is stored in top-level collections.
 * - Stores and Products are top-level collections with an ownerId on the store to control write access.
 *
 * Key Security Decisions:
 * - User listing is implicitly denied.
 * - Public read access is granted only to the explicitly designated `quests` and `rewards` collections.
 * - Data validation is minimized for prototyping, focusing solely on ownership and relational integrity.
 *
 * Denormalization for Authorization:
 * - The `User` document stores the user's `role` and `level` directly, avoiding costly `get()` calls to a separate roles collection during authorization checks.
 * - The `Store` document stores the `ownerId` directly, allowing for simple owner-based access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their own user document.
     *   - Request: auth.uid = 'user123', resource.data.id = 'user123'
     * @allow (get, update, delete) User with ID 'user123' can read/update/delete their own user document.
     *   - Request: auth.uid = 'user123'
     * @deny (create) User with ID 'user456' cannot create a user document for 'user123'.
     *   - Request: auth.uid = 'user456', resource.data.id = 'user123'
     * @deny (get, update, delete) User with ID 'user456' cannot read/update/delete user document 'user123'.
     *   - Request: auth.uid = 'user456'
     * @principle Enforces document ownership for writes and reads.  Allows self-creation with ID validation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/profile/{profileId} collection.
     * @path /users/{userId}/profile/{profileId}
     * @allow (create, get, update, delete) User with ID 'user123' can manage their own profile.
     *   - Request: auth.uid = 'user123'
     * @deny (create, get, update, delete) User with ID 'user456' cannot manage profile of user 'user123'.
     *   - Request: auth.uid = 'user456'
     * @principle Restricts access to a user's own profile data.
     */
    match /users/{userId}/profile/{profileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/downline/{memberId} collection.
     * @path /users/{userId}/downline/{memberId}
     * @allow (create, get, update, delete) User with ID 'user123' can manage their own downline members.
     *   - Request: auth.uid = 'user123'
     * @deny (create, get, update, delete) User with ID 'user456' cannot manage downline members of user 'user123'.
     *   - Request: auth.uid = 'user456'
     * @principle Restricts access to a user's own downline data.
     */
    match /users/{userId}/downline/{memberId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.memberId == memberId;
      allow update: if isExistingOwner(userId) && request.resource.data.memberId == resource.data.memberId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/notifications/{notificationId} collection.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create, get, update, delete) User with ID 'user123' can manage their own notifications.
     *   - Request: auth.uid = 'user123'
     * @deny (create, get, update, delete) User with ID 'user456' cannot manage notifications of user 'user123'.
     *   - Request: auth.uid = 'user456'
     * @principle Restricts access to a user's own notification data.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /quests/{questId} collection.
     * @path /quests/{questId}
     * @allow (get, list) Anyone can read quest data.
     *   - Request: (Unauthenticated or any auth.uid)
     * @deny (create, update, delete) Only authenticated owner user can create, update, or delete quest data.
     *   - Request: auth.uid = 'user456'
     * @principle Allows public read access to quests, but restricts writes.
     */
    match /quests/{questId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /rewards/{rewardId} collection.
     * @path /rewards/{rewardId}
     * @allow (get, list) Anyone can read reward data.
     *   - Request: (Unauthenticated or any auth.uid)
     * @deny (create, update, delete) Only authenticated owner user can create, update, or delete reward data.
     *   - Request: auth.uid = 'user456'
     * @principle Allows public read access to rewards, but restricts writes.
     */
    match /rewards/{rewardId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /stores/{storeId} collection.
     * @path /stores/{storeId}
     * @allow (get, list) Anyone can read store data.
     *   - Request: (Unauthenticated or any auth.uid)
     * @allow (create, update, delete) Only the store owner can manage the store.
     *   - Request: auth.uid = 'user123', resource.data.ownerId = 'user123'
     * @deny (create, update, delete) User with ID 'user456' cannot manage store owned by 'user123'.
     *   - Request: auth.uid = 'user456', resource.data.ownerId = 'user123'
     * @principle Enforces store ownership for writes.
     */
    match /stores/{storeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rules for the /products/{productId} collection.
     * @path /products/{productId}
     * @allow (get, list) Anyone can read product data.
     *   - Request: (Unauthenticated or any auth.uid)
     * @deny (create, update, delete) Only authenticated owner user can create, update, or delete product data.
     * @principle Allows public read access to products, but restricts writes.  Write access should be controlled through the store owner.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation through Store ownership. Product entity is missing an ownerId.
    }

    /**
     * @description Rules for the /users/{userId}/ai_sessions/{aiSessionId} collection.
     * @path /users/{userId}/ai_sessions/{aiSessionId}
     * @allow (create, get, update, delete) User with ID 'user123' can manage their own AI sessions.
     *   - Request: auth.uid = 'user123'
     * @deny (create, get, update, delete) User with ID 'user456' cannot manage AI sessions of user 'user123'.
     *   - Request: auth.uid = 'user456'
     * @principle Restricts access to a user's own AI session data.
     */
    match /users/{userId}/ai_sessions/{aiSessionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/wallet/{walletId} collection.
     * @path /users/{userId}/wallet/{walletId}
     * @allow (create, get, update, delete) User with ID 'user123' can manage their own wallet.
     *   - Request: auth.uid = 'user123'
     * @deny (create, get, update, delete) User with ID 'user456' cannot manage wallet of user 'user123'.
     *   - Request: auth.uid = 'user456'
     * @principle Restricts access to a user's own wallet data.
     */
    match /users/{userId}/wallet/{walletId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    // --- Helper functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}