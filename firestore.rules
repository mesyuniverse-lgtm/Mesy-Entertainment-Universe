/**
 * @fileOverview Firestore Security Rules for the Mesy Entertainment Universe platform.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data stored under the `/members/{memberId}` path.
 * Public data, such as quests and rewards, is readable by all users but can only be created, updated, or deleted by authorized users (e.g., admins - not yet implemented here).
 *
 * Data Structure:
 * - Member-specific data (profiles, wallets, AI sessions, downlines, notifications) is nested under `/members/{memberId}`.
 * - Global data (quests, rewards, stores) resides in top-level collections like `/quests`, `/rewards`, and `/stores`.
 *
 * Key Security Decisions:
 * - Members can only access their own data under `/members/{memberId}`.
 * - Listing operations are secured based on path-based ownership (e.g., a member can list their own notifications).
 * - Data validation is limited to enforcing ownership and relational integrity.
 * - The exact schema is not enforced to allow for rapid prototyping.
 *
 * Denormalization for Authorization:
 *  - Member-specific data is stored under the `/members/{memberId}` path, enabling direct authorization checks without additional `get()` calls.
 *  - Stores have the `ownerId` denormalized, enabling quick checks.
 *
 * Structural Segregation:
 * - Private member data is stored under `/members/{memberId}`, while shared data like stores are in a separate top-level collection `/stores`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rules for the /members/{memberId} collection. Allows members to read and write their own member document.
     * @path /members/{memberId}
     * @allow (create) Member with ID 'user_abc' can create their own document if request.auth.uid == 'user_abc'.
     * @allow (get) Member with ID 'user_abc' can read their own document.
     * @allow (update) Member with ID 'user_abc' can update their own document.
     * @allow (delete) Member with ID 'user_abc' can delete their own document.
     * @deny (create) Member with ID 'user_xyz' cannot create a document with ID 'user_abc'.
     * @principle Enforces document ownership for writes.
     */
    match /members/{memberId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(memberId) {
        return isSignedIn() && request.auth.uid == memberId;
      }

      function isExistingOwner(memberId) {
        return isOwner(memberId) && resource != null;
      }

      allow get: if isOwner(memberId);
      allow list: if false; // Listing all members is not permitted.
      allow create: if isOwner(memberId) && request.resource.data.id == memberId;
      allow update: if isExistingOwner(memberId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(memberId);

        /**
       * @description Rules for the /members/{memberId}/profile/{profileId} subcollection. Allows members to manage their own profile, but allows public read access.
       * @path /members/{memberId}/profile/{profileId}
       * @allow (get) Anyone can read a member's profile.
       * @allow (list) Anyone can list profiles.
       * @allow (write) Only the owner can create, update, or delete their own profile.
       * @principle Public read, owner-only write for profiles.
       */
      match /profile/{profileId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(memberId) && request.resource.data.memberId == memberId;
        allow update: if isExistingOwner(memberId) && request.resource.data.memberId == resource.data.memberId;
        allow delete: if isExistingOwner(memberId);
      }

       /**
       * @description Rules for the /members/{memberId}/downline/{downlineMemberId} collection. Allows members to read and write their own downline members.
       * @path /members/{memberId}/downline/{downlineMemberId}
       * @allow (create) Member with ID 'user_abc' can create a downline member if request.auth.uid == 'user_abc'.
       * @allow (get) Member with ID 'user_abc' can read a downline member.
       * @allow (update) Member with ID 'user_abc' can update a downline member.
       * @allow (delete) Member with ID 'user_abc' can delete a downline member.
       * @deny (create) Member with ID 'user_xyz' cannot create a downline member with memberId 'user_abc'.
       * @principle Enforces document ownership for writes.
       */
      match /downline/{downlineMemberId} {
        allow get: if isOwner(memberId);
        allow list: if isOwner(memberId);
        allow create: if isOwner(memberId);
        allow update: if isExistingOwner(memberId);
        allow delete: if isExistingOwner(memberId);
      }

      /**
       * @description Rules for the /members/{memberId}/notifications/{notificationId} collection. Allows members to read and write their own notifications.
       * @path /members/{memberId}/notifications/{notificationId}
       * @allow (create) Member with ID 'user_abc' can create a notification if request.auth.uid == 'user_abc'.
       * @allow (get) Member with ID 'user_abc' can read a notification.
       * @allow (update) Member with ID 'user_abc' can update a notification.
       * @allow (delete) Member with ID 'user_abc' can delete a notification.
       * @deny (create) Member with ID 'user_xyz' cannot create a notification with memberId 'user_abc'.
       * @principle Enforces document ownership for writes.
       */
      match /notifications/{notificationId} {
        allow get: if isOwner(memberId);
        allow list: if isOwner(memberId);
        allow create: if isOwner(memberId);
        allow update: if isExistingOwner(memberId);
        allow delete: if isExistingOwner(memberId);
      }

      /**
       * @description Rules for the /members/{memberId}/ai_sessions/{sessionId} collection. Allows members to read and write their own AI sessions.
       * @path /members/{memberId}/ai_sessions/{sessionId}
       * @allow (create) Member with ID 'user_abc' can create an AI session if request.auth.uid == 'user_abc'.
       * @allow (get) Member with ID 'user_abc' can read an AI session.
       * @allow (update) Member with ID 'user_abc' can update an AI session.
       * @allow (delete) Member with ID 'user_abc' can delete an AI session.
       * @deny (create) Member with ID 'user_xyz' cannot create an AI session with memberId 'user_abc'.
       * @principle Enforces document ownership for writes.
       */
      match /ai_sessions/{sessionId} {
        allow get: if isOwner(memberId);
        allow list: if isOwner(memberId);
        allow create: if isOwner(memberId) && request.resource.data.memberId == memberId;
        allow update: if isExistingOwner(memberId) && request.resource.data.memberId == resource.data.memberId;
        allow delete: if isExistingOwner(memberId);
      }

      /**
       * @description Rules for the /members/{memberId}/wallet/{walletId} collection. Allows members to read and write their own wallet.
       * @path /members/{memberId}/wallet/{walletId}
       * @allow (create) Member with ID 'user_abc' can create a wallet if request.auth.uid == 'user_abc'.
       * @allow (get) Member with ID 'user_abc' can read their wallet.
       * @allow (update) Member with ID 'user_abc' can update their wallet.
       * @allow (delete) Member with ID 'user_abc' can delete their wallet.
       * @deny (create) Member with ID 'user_xyz' cannot create a wallet with memberId 'user_abc'.
       * @principle Enforces document ownership for writes.
       */
      match /wallet/{walletId} {
        allow get: if isOwner(memberId);
        allow list: if false; // Listing wallets is not permitted.
        allow create: if isOwner(memberId) && request.resource.data.memberId == memberId;
        allow update: if isExistingOwner(memberId) && request.resource.data.memberId == resource.data.memberId;
        allow delete: if isExistingOwner(memberId);

        /**
        * @description Rules for the /members/{memberId}/wallet/{walletId}/transactions/{transactionId} collection. Allows members to manage their own transactions.
        * @path /members/{memberId}/wallet/{walletId}/transactions/{transactionId}
        * @allow (read, write) Only the owner (based on the top-level {memberId}) can access their own transactions.
        * @principle Enforces deep document ownership.
        */
        match /transactions/{transactionId} {
            allow read, write: if isOwner(memberId);
        }
      }
    }
    
    /**
     * @description Rules for the /mesy-members/{memberId} collection. Allows any authenticated member to read, but write is restricted.
     * @path /mesy-members/{memberId}
     * @allow (read) Any signed-in member can read the list of MESY members.
     * @deny (write) Writes are currently disabled from the client for security. Should be handled by backend/admin processes.
     * @principle Public read, restricted write for special member data.
     */
    match /mesy-members/{memberId} {
        function isSignedIn() {
          return request.auth != null;
        }
        
        allow read: if isSignedIn();
        allow write: if false; // Restricted to admin/server-side operations
    }

    /**
     * @description Rules for the /quests/{questId} collection. Allows anyone to read quests, but only authorized users can create, update, or delete them.
     * @path /quests/{questId}
     * @allow (get) Anyone can read a quest.
     * @allow (list) Anyone can list quests.
     * @deny (create) Only authorized users (e.g., admins) should be able to create quests.
     * @deny (update) Only authorized users (e.g., admins) should be able to update quests.
     * @deny (delete) Only authorized users (e.g., admins) should be able to delete quests.
     * @principle Public read, restricted write.
     */
    match /quests/{questId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add admin role check
      allow update: if false; // TODO: Add admin role check
      allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for the /rewards/{rewardId} collection. Allows anyone to read rewards, but only authorized users can create, update, or delete them.
     * @path /rewards/{rewardId}
     * @allow (get) Anyone can read a reward.
     * @allow (list) Anyone can list rewards.
     * @deny (create) Only authorized users (e.g., admins) should be able to create rewards.
     * @deny (update) Only authorized users (e.g., admins) should be able to update rewards.
     * @deny (delete) Only authorized users (e.g., admins) should be able to delete rewards.
     * @principle Public read, restricted write.
     */
    match /rewards/{rewardId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add admin role check
      allow update: if false; // TODO: Add admin role check
      allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for the /stores/{storeId} collection. Allows anyone to read stores, but only the store owner can create, update, or delete them.
     * @path /stores/{storeId}
     * @allow (get) Anyone can read a store.
     * @allow (list) Anyone can list stores.
     * @allow (create) Only the store owner can create a store, and the ownerId must match the authenticated user's UID.
     * @allow (update) Only the store owner can update a store.
     * @allow (delete) Only the store owner can delete a store.
     * @deny (create) User cannot create a store for another owner.
     * @principle Public read, owner-only write.
     */
    match /stores/{storeId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(ownerId) {
        return isSignedIn() && request.auth.uid == ownerId;
      }

      function isExistingOwner(ownerId) {
        return isOwner(ownerId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }
  }
}

    